# c++基础课程
## 第1课第1节_c++类的引入
c++中对结构体做的扩展：  
- 类是结构体的升级版
- c++中的结构体可以直接定义函数，函数可以直接访问结构体成员
- 面向对象编程的三大特点
    - 封装
    - 继承
    - 多态

## 第2课第1节_c++基础知识_访问控制
1. `private`控制域下的变量不能被类的外部访问，若需访问，可以在`public`中提供一些函数来修改变量。
2. `this`指针指向这个类本身，若在类内需要访问某个变量，可以使用`this->age`的方式来访问。

## 第2课第2节_c++基础知识_程序结构
1. 函数声明可以放在类的内部，实现可以放在类的外部，在外部添加类的作用域即可。
2. 一般把类的声明放在头文件中，把实现放在同名cpp文件中，调用时添加该头文件即可。
3. 使用命名空间可以避免同名函数/变量定义冲突的现象。
4. 使用命名空间的三种方式：
- 直接使用——a::fun();
- using声明——using a::fun;
- using编译——using namespace a;

## 第2课第3节_c++基础知识_重载_指针_引用
1. 重载  
通过参数类型、个数的不同重载同名函数。
2. 指针  
c++中的指针用法与c中完全相同。
3. 引用  
- 这是c++才有的特性
- 引用 == 别名
```C
int &c = a;
```
代表c是变量a的别名。

## 第2课第4节_c++基础知识_构造函数
1. 构造函数在实例化一个对象时调用，可重载。
2. 调用默认的构造函数时不需要加`()`，否则将变成函数声明。
```c
Person per3();
```
在`new`时可以添加`()`，这里调用构造函数。
```c
Person *per5 = new Person();
```
3. `new` 和 `delete` 分别对应c中的`malloc` 和 `free`。  
delete 一个数组时，加上中括号——`delete []per6;`。
4. 如果在构造函数中申请内存，需要在析构函数中释放内存，否则会造成内存泄露。  
`new`申请的内存在函数/程序运行结束结束时会自动释放。  
- 程序内存查看方法
    - 在linux中使用`free`命令可查看内存适用情况。
    - 在linux中使用`Valgrind`工具查看
    [使用 Valgrind 检测 C++ 内存泄漏](http://senlinzhan.github.io/2017/12/31/valgrind/)
- 分类讨论内存的释放
    - 局部变量
    在函数结束时释放，调用析构函数释放构造函数中申请的内存。
    - new的对象
    delete时释放，调用析构函数释放构造函数中申请的内存，若未定义对应的析构函数或析构函数不作为，则构造函数中申请的内存在程序结束时才被OS回收， 此时回收时不会调用类内部的析构函数。

5. 类的拷贝构造函数
```c
	Person per("zhangsan", 18);
	Person per2(per);
```
c++中的拷贝默认的是值拷贝，此时`per`和`per2`中的`name`成员指向同一块内存，释放两个变量会导致同一块内存被释放两次，所以需要自己实现拷贝函数，自行分配内存。

6. 构造顺序：按运行中定义对象的顺序调用构造函数，静态对象只调用一次构造函数; 全局对象在main函数执行前被构造

7. 如果在类里定义了带参数的构造函数，则也要一起定义无参的构造函数，因为此时系统不会帮你构造。 
要调用对象成员的其他构造函数，可以这样写: 
```C
/* 调用id类的构造函数 */
Student(int sID) : id(sID) 
```
构造函数的""前加":"，加上成员的初始化代码
对象成员：按定义时的顺序构造，与上述初始化代码顺序无关
析构函数被调用的顺序：相反

## 第2课第5节_c++基础知识_静态成员_友员
## 第2课第6.1节_c++基础知识_运算符重载_类外函数
1. 如何在调用时区分前置和后置运算符
c++ primer中通过显示调用区分
而视频中的例程则似乎通过编译器的特性来区分。

2. 值返回和引用返回的区别
- 值返回
构造一个临时对象来返回，会依次调用该类的构造和析构函数，效率较低。
- 引用返回
直接返回一个引用，无需重新构造，效率较高。

3. `=`运算符的引用注意区分`拷贝构造` 和 `operator=`
**原则**：不影响运算结果时，效率优先。后置++运算符只能返回值，前置++可以返回引用。

## 第2课第6.2节_c++基础知识_运算符重载_成员函数
## 第3课第1节_c++面向对象编程_访问控制和继承
1. 子类继承父类的成员函数之后可以覆写。
2. 在改写`person_student.cpp`文件时，发现`c`和`c++`中字符串参数的差异：
>The problem is that you are trying to convert a string literal (with type const char[]) to char*.You can convert a const char[] to const char* because the array decays to the pointer, but what you are doing is making a mutable a constant.

解决方法：
```
Person p((char *)"lisi", 16);
```
3. 子类可见到的成员，可以修改它的权限。
`private: using Father::getMoney;`

## 第3课第2节_c++面向对象编程_多重继承
一个派生类可以有多个基类
使用`虚拟继承`来使父类继承继承一个祖父类来解决多重继承带来的`二义性`问题。
若一个类被多次虚拟继承，只需要构造一次。
如下面11th_`Sofabed3.cpp`所示：
```
Sofabed
	Sofa
		Furniture
	Bed
		Furniture
```
下面创建第二个虚拟继承`Furniture`的类时，就不再调用`Furniture`的构造函数。
>可以考虑使用`EA`来分析类之间的关系
[安装EA](http://www.northdatanet.net/mf/2018/0729/224558.html)


## 第3课第3节_c++面向对象编程_再论构造函数
构造的顺序问题

## 第4课第1节_c++面向对象编程_多态

第4课第2节_c++面向对象编程_类型转换 12/28
第5课第1节_c++高级编程_抽象类_概念 7
第5课第2节_c++高级编程_抽象类界面 42
第6课第1节_c++高级编程_函数模板_引入 20
第6课第2节_c++高级编程_函数模板_重载 38
第6课第3节_c++高级编程_类模板 9
第7课_c++高级编程_异常 28
第8课第1节_c++高级编程_自己实现智能指针 35
第8课第2节_c++高级编程_Android轻量级指针 11
第8课第3节_c++高级编程_Android弱指针的引入 21
第8课第4节_c++高级编程_Android强弱指针的实现与使用 34
第9课第1节_设计模式_单例模式 21
第9课第2节_设计模式_桥接模式 18