# c++基础课程
## 第1课第1节_c++类的引入
c++中对结构体做的扩展：  
- 类是结构体的升级版
- c++中的结构体可以直接定义函数，函数可以直接访问结构体成员
- 面向对象编程的三大特点
    - 封装
    - 继承
    - 多态

## 第2课第1节_c++基础知识_访问控制
1. `private`控制域下的变量不能被类的外部访问，若需访问，可以在`public`中提供一些函数来修改变量。
2. `this`指针指向这个类本身，若在类内需要访问某个变量，可以使用`this->age`的方式来访问。

## 第2课第2节_c++基础知识_程序结构
1. 函数声明可以放在类的内部，实现可以放在类的外部，在外部添加类的作用域即可。
2. 一般把类的声明放在头文件中，把实现放在同名cpp文件中，调用时添加该头文件即可。
3. 使用命名空间可以避免同名函数/变量定义冲突的现象。
4. 使用命名空间的三种方式：
- 直接使用——a::fun();
- using声明——using a::fun;
- using编译——using namespace a;

## 第2课第3节_c++基础知识_重载_指针_引用
1. 重载  
通过参数类型、个数的不同重载同名函数。
2. 指针  
c++中的指针用法与c中完全相同。
3. 引用  
- 这是c++才有的特性
- 引用 == 别名
```C
int &c = a;
```
代表c是变量a的别名。

## 第2课第4节_c++基础知识_构造函数
1. 构造函数在实例化一个对象时调用，可重载。
2. 调用默认的构造函数时不需要加`()`，否则将变成函数声明。
```c
Person per3();
```
在`new`时可以添加`()`，这里调用构造函数。
```c
Person *per5 = new Person();
```
3. `new` 和 `delete` 分别对应c中的`malloc` 和 `free`。  
delete 一个数组时，加上中括号——`delete []per6;`。
4. 如果在构造函数中申请内存，需要在析构函数中释放内存，否则会造成内存泄露。  
`new`申请的内存在函数/程序运行结束结束时会自动释放。  
- 程序内存查看方法
    - 在linux中使用`free`命令可查看内存适用情况。
    - 在linux中使用`Valgrind`工具查看
    [使用 Valgrind 检测 C++ 内存泄漏](http://senlinzhan.github.io/2017/12/31/valgrind/)
- 分类讨论内存的释放
    - 局部变量
    在函数结束时释放，调用析构函数释放构造函数中申请的内存。
    - new的对象
    delete时释放，调用析构函数释放构造函数中申请的内存，若未定义对应的析构函数或析构函数不作为，则构造函数中申请的内存在程序结束时才被OS回收， 此时回收时不会调用类内部的析构函数。

5. 类的拷贝构造函数
```c
	Person per("zhangsan", 18);
	Person per2(per);
```
c++中的拷贝默认的是值拷贝，此时`per`和`per2`中的`name`成员指向同一块内存，释放两个变量会导致同一块内存被释放两次，所以需要自己实现拷贝函数，自行分配内存。

6. 构造顺序：按运行中定义对象的顺序调用构造函数，静态对象只调用一次构造函数; 全局对象在main函数执行前被构造

7. 如果在类里定义了带参数的构造函数，则也要一起定义无参的构造函数，因为此时系统不会帮你构造。 
要调用对象成员的其他构造函数，可以这样写: 
```C
/* 调用id类的构造函数 */
Student(int sID) : id(sID) 
```
构造函数的""前加":"，加上成员的初始化代码
对象成员：按定义时的顺序构造，与上述初始化代码顺序无关
析构函数被调用的顺序：相反

第2课第5节_c++基础知识_静态成员_友员
第2课第6.1节_c++基础知识_运算符重载_类外函数
第2课第6.2节_c++基础知识_运算符重载_成员函数
第3课第1节_c++面向对象编程_访问控制和继承
第3课第2节_c++面向对象编程_多重继承
第3课第3节_c++面向对象编程_再论构造函数
第4课第1节_c++面向对象编程_多态
第4课第2节_c++面向对象编程_类型转换
第5课第1节_c++高级编程_抽象类_概念
第5课第2节_c++高级编程_抽象类界面
第6课第1节_c++高级编程_函数模板_引入
第6课第2节_c++高级编程_函数模板_重载
第6课第3节_c++高级编程_类模板
第7课_c++高级编程_异常
第8课第1节_c++高级编程_自己实现智能指针
第8课第2节_c++高级编程_Android轻量级指针
第8课第3节_c++高级编程_Android弱指针的引入
第8课第4节_c++高级编程_Android强弱指针的实现与使用
第9课第1节_设计模式_单例模式
第9课第2节_设计模式_桥接模式